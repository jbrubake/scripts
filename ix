#!/bin/bash
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# Copyright 2023 Jeremy Brubaker <jbru362@gmail.com>
#
# abstract: ix.io wrapper
#
# https://raw.githubusercontent.com/DanielFGray/fzf-scripts/master/ix
#
NETRC_DFLT=$HOME/.netrc
VERSION='1.0'

URL=http://ix.io
export URL # needed by fzf bind commands

# Functions {{{1
#
# get_user_name {{{2
#
# @description Get ix.io username from netrc file
#
# @arg $1 string Path to netrc file
#
# @stdout ix.io username
#
get_user_name() { awk '"ix.io" == $2 { print $4 }' "$1"; }
export -f get_user_name

# get_pastes {{{2
#
# @description Extract and format ix.io pastes from stdin
#
# @noargs
#
# @stdin ix.io list of pastes in html
#
# @stdout [ID] [NAME] [DATE]
#
get_pastes() {
    grep -A1 -P '\<a href="\/[[:alnum:]]+"\>' |
    awk '
      /a href/ {
        sub("^[^/]*/", "", $0)
        sub(/".*/, "", $0)
        id = $0 }
      /@/ {
        sub(/^\s+/, "", $0)
        printf("%s\t%s\n", id, $0) }' |
    sed 's/@ /	/' |
    column -t -s'	'
}
export -f get_pastes

# do_list {{{2
#
# @description Print a table of ix.io pastes. Default is to list *your* pastes
#
# @arg $1 string Path to netrc file
# @arg $1 option -a | -u [USER]: anonymous or USER pastes (optional)
#
# @stdout Formatted list of pastes
#
do_list() {
    netrc=$1; shift

    case $1 in
        -a) url="$URL/user/";   shift ;;
        -u) url="$URL/user/$2"; shift 2 ;;
        *)  url="$URL/user/$(get_user_name "$netrc")" ;;
    esac

    curl -s "$url" | get_pastes
}
export -f do_list

# do_get {{{2
#
# @description Get an ix.io paste by ID
#
# @arg $1 string ID of paste to get
#
# @stdout ix.io/ID paste
#
do_get() {
    for id in "$@"; do
        curl -s $cmd "$URL/$id"
    done
}
export -f do_get

# do_delete() {{{2
#
# @description Delete an ix.io paste by ID
#
# @arg $1 string Path to netrc file
# @arg $2 string ID of paste to delete
#
do_delete() {
    netrc=$1; shift
    for id in "$@"; do
        curl -s --netrc-file "$netrc" -X DELETE "$URL/$id"
    done
}
export -f do_delete

# do_replace() {{{2
#
# @description Replace an ix.io paste by ID
#
# @arg $1 string Path to netrc file
# @arg $2 string ID of paste to replace
#
# @stdin What to replace paste with
#
do_replace() {
    if [ $# -ge 2 ]; then
        netrc=$1; shift
        id=$1; shift

        # Prompt if stdin is a tty
        [ -t 0 ] && \
            printf "%s\n" "Enter data to paste. ^c to cancel, ^d to send" >&2
        cat "$@" | curl -s --netrc-file "$netrc" -X PUT -F f:1='<-' "$URL/$id"
    fi
}
export -f do_replace

# do_edit() {{{2
#
# @description Edit an ix.io paste by ID
#
# @arg $1 string Path to netrc file
# @arg $2 string ID of paste to edit
#
do_edit() {
    if [ $# -eq 2 ]; then
        curl -s --netrc-file "$1" "$URL/$2" | vipe | do_replace "$1" "$2"
    fi
}
export -f do_edit

# do_paste() {{{2
#
# @description Paste files or stdin to ix.io if no files are given
#
# @arg $1 string Path to netrc file
# @arg $2 option -a Paste anonymously (optional)
# @arg $@ filename List of filenames to paste. Ending a filename with ':<type'
#   will set the filetype (optional)
#
# @stdin Data to paste
#
# @stdout ix.io paste ID
#
do_paste() {
    netrc=$1; shift

    # Anonymous paste?
    if [ "$1" = '-a' ]; then
        opt=
        shift
    else
        opt="--netrc-file $netrc"
    fi

    if [ $# -gt 0 ]; then
        i=1
        for f in $@; do
            # Use ':<type>' appended to files as the type
            case $f in
                *:*) opt="$opt -F f:$i=@${f%:*} -F ext:$i=.${f##*:}" ;;
                *)   opt="$opt -F f:$i=@$f" ;;
            esac
            i=$((i+1))
        done
    else
        opt="$opt -F f:1=<-"
        # Prompt if stdin is a tty
        [ -t 0 ] && \
            printf "%s\n" "Enter data to paste. ^c to cancel, ^d to send" >&2
    fi
    curl -s $opt "$URL"
}
export -f do_paste

# Process options {{{1

# Parse args {{{3
#
# @include ix-parsers
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
REST=''
parse_main() {
	OPTIND=$(($#+1))
	while OPTARG= && [ $# -gt 0 ]; do
		case $1 in
			--?*=*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
				;;
			--no-*|--without-*) unset OPTARG ;;
			-[hv]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
				OPTARG= ;;
		esac
		case $1 in
			'-h'|'--help')
				usage_main
				exit 0 ;;
			'-v'|'--version')
				echo "${VERSION}"
				exit 0 ;;
			--)
				while [ $# -gt 0 ]; do
					REST="${REST} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
			[-]?*) set "unknown" "$1"; break ;;
			*)
				case $1 in 'fzf'|'list'|'get'|'delete'|'paste'|'replace'|'edit') ;;
					*) set "notcmd" "$1"; break
				esac
				while [ $# -gt 0 ]; do
					REST="${REST} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
		esac
		shift
	done
	[ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
	case $1 in
		unknown) set "Unrecognized option: $2" "$@" ;;
		noarg) set "Does not allow an argument: $2" "$@" ;;
		required) set "Requires an argument: $2" "$@" ;;
		pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
		notcmd) set "Not a command: $2" "$@" ;;
		*) set "Validation error ($1): $2" "$@"
	esac
	echo "$1" >&2
	exit 1
}
usage_main() {
cat<<'GETOPTIONSHERE'
Usage: ix [OPTION] [COMMAND]

ix.io client

Options:
  -h, --help                  display this help and exit
  -v, --version               output version information and quit

Commands:
  fzf       start fzf interface
  list      list pastes
  get       get ID
  delete    delete ID
  paste     paste [FILE] ... If no FILEs then paste stdin
  replace   replace ID with stdin
  edit      edit ID
GETOPTIONSHERE
}
# Generated by getoptions (END)
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
NETRC=''
REST=''
parse_fzf() {
	OPTIND=$(($#+1))
	while OPTARG= && [ $# -gt 0 ]; do
		case $1 in
			--?*=*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
				;;
			--no-*|--without-*) unset OPTARG ;;
			-[N]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" "${OPTARG#??}"' ${1+'"$@"'}
				;;
			-[h]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
				OPTARG= ;;
		esac
		case $1 in
			'-N'|'--netrc')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				NETRC="$OPTARG"
				shift ;;
			'-h'|'--help')
				usage_fzf
				exit 0 ;;
			--)
				shift
				while [ $# -gt 0 ]; do
					REST="${REST} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
			[-]?*) set "unknown" "$1"; break ;;
			*)
				REST="${REST} \"\${$(($OPTIND-$#))}\""
		esac
		shift
	done
	[ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
	case $1 in
		unknown) set "Unrecognized option: $2" "$@" ;;
		noarg) set "Does not allow an argument: $2" "$@" ;;
		required) set "Requires an argument: $2" "$@" ;;
		pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
		notcmd) set "Not a command: $2" "$@" ;;
		*) set "Validation error ($1): $2" "$@"
	esac
	echo "$1" >&2
	exit 1
}
usage_fzf() {
cat<<'GETOPTIONSHERE'
Usage: ix fzf [OPTION]

Start fzf interface to ix.io

Options:
  -N, --netrc NETRC           path to netrc file (default: /home/jbrubake/.netrc)
  -h, --help                  display this help and exit
GETOPTIONSHERE
}
# Generated by getoptions (END)
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
ANON=''
WHO=''
NETRC=''
REST=''
parse_list() {
	OPTIND=$(($#+1))
	while OPTARG= && [ $# -gt 0 ]; do
		case $1 in
			--?*=*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
				;;
			--no-*|--without-*) unset OPTARG ;;
			-[uN]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" "${OPTARG#??}"' ${1+'"$@"'}
				;;
			-[ah]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
				OPTARG= ;;
		esac
		case $1 in
			'-a'|'--anon')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
				ANON="$OPTARG"
				;;
			'-u'|'--user')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				WHO="$OPTARG"
				shift ;;
			'-N'|'--netrc')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				NETRC="$OPTARG"
				shift ;;
			'-h'|'--help')
				usage_list
				exit 0 ;;
			--)
				shift
				while [ $# -gt 0 ]; do
					REST="${REST} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
			[-]?*) set "unknown" "$1"; break ;;
			*)
				REST="${REST} \"\${$(($OPTIND-$#))}\""
		esac
		shift
	done
	[ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
	case $1 in
		unknown) set "Unrecognized option: $2" "$@" ;;
		noarg) set "Does not allow an argument: $2" "$@" ;;
		required) set "Requires an argument: $2" "$@" ;;
		pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
		notcmd) set "Not a command: $2" "$@" ;;
		*) set "Validation error ($1): $2" "$@"
	esac
	echo "$1" >&2
	exit 1
}
usage_list() {
cat<<'GETOPTIONSHERE'
Usage: ix list [OPTION]

List pastes. Default is to list pastes for the user specified in .netrc

Options:
  -a, --anon                  list anonymous pastes
  -u, --user WHO              list WHO's pastes
  -N, --netrc NETRC           path to netrc file (default: /home/jbrubake/.netrc)
  -h, --help                  display this help and exit
GETOPTIONSHERE
}
# Generated by getoptions (END)
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
REST=''
parse_get() {
	OPTIND=$(($#+1))
	while OPTARG= && [ $# -gt 0 ]; do
		case $1 in
			--?*=*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
				;;
			--no-*|--without-*) unset OPTARG ;;
			-[h]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
				OPTARG= ;;
		esac
		case $1 in
			'-h'|'--help')
				usage_get
				exit 0 ;;
			--)
				shift
				while [ $# -gt 0 ]; do
					REST="${REST} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
			[-]?*) set "unknown" "$1"; break ;;
			*)
				REST="${REST} \"\${$(($OPTIND-$#))}\""
		esac
		shift
	done
	[ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
	case $1 in
		unknown) set "Unrecognized option: $2" "$@" ;;
		noarg) set "Does not allow an argument: $2" "$@" ;;
		required) set "Requires an argument: $2" "$@" ;;
		pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
		notcmd) set "Not a command: $2" "$@" ;;
		*) set "Validation error ($1): $2" "$@"
	esac
	echo "$1" >&2
	exit 1
}
usage_get() {
cat<<'GETOPTIONSHERE'
Usage: ix get [ID] ...

Dump pastes for each ID to stdout

Options:
  -h, --help                  display this help and exit
GETOPTIONSHERE
}
# Generated by getoptions (END)
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
NETRC=''
REST=''
parse_delete() {
	OPTIND=$(($#+1))
	while OPTARG= && [ $# -gt 0 ]; do
		case $1 in
			--?*=*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
				;;
			--no-*|--without-*) unset OPTARG ;;
			-[N]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" "${OPTARG#??}"' ${1+'"$@"'}
				;;
			-[h]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
				OPTARG= ;;
		esac
		case $1 in
			'-N'|'--netrc')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				NETRC="$OPTARG"
				shift ;;
			'-h'|'--help')
				usage_delete
				exit 0 ;;
			--)
				shift
				while [ $# -gt 0 ]; do
					REST="${REST} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
			[-]?*) set "unknown" "$1"; break ;;
			*)
				REST="${REST} \"\${$(($OPTIND-$#))}\""
		esac
		shift
	done
	[ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
	case $1 in
		unknown) set "Unrecognized option: $2" "$@" ;;
		noarg) set "Does not allow an argument: $2" "$@" ;;
		required) set "Requires an argument: $2" "$@" ;;
		pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
		notcmd) set "Not a command: $2" "$@" ;;
		*) set "Validation error ($1): $2" "$@"
	esac
	echo "$1" >&2
	exit 1
}
usage_delete() {
cat<<'GETOPTIONSHERE'
Usage: ix delete [OPTION] [ID] ...

Deleete pastes for each ID

Options:
  -N, --netrc NETRC           path to netrc file (default: /home/jbrubake/.netrc)
  -h, --help                  display this help and exit
GETOPTIONSHERE
}
# Generated by getoptions (END)
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
ANON=''
NETRC=''
REST=''
parse_paste() {
	OPTIND=$(($#+1))
	while OPTARG= && [ $# -gt 0 ]; do
		case $1 in
			--?*=*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
				;;
			--no-*|--without-*) unset OPTARG ;;
			-[N]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" "${OPTARG#??}"' ${1+'"$@"'}
				;;
			-[ah]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
				OPTARG= ;;
		esac
		case $1 in
			'-a'|'--anon')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
				ANON="$OPTARG"
				;;
			'-N'|'--netrc')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				NETRC="$OPTARG"
				shift ;;
			'-h'|'--help')
				usage_paste
				exit 0 ;;
			--)
				shift
				while [ $# -gt 0 ]; do
					REST="${REST} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
			[-]?*) set "unknown" "$1"; break ;;
			*)
				REST="${REST} \"\${$(($OPTIND-$#))}\""
		esac
		shift
	done
	[ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
	case $1 in
		unknown) set "Unrecognized option: $2" "$@" ;;
		noarg) set "Does not allow an argument: $2" "$@" ;;
		required) set "Requires an argument: $2" "$@" ;;
		pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
		notcmd) set "Not a command: $2" "$@" ;;
		*) set "Validation error ($1): $2" "$@"
	esac
	echo "$1" >&2
	exit 1
}
usage_paste() {
cat<<'GETOPTIONSHERE'
Usage: ix paste [OPTION] [FILE] ...

Paste stdin or each FILE. Appending ':<filetype>' to FILE sets its filetype

Options:
  -a, --anon                  paste anonymously
  -N, --netrc NETRC           path to netrc file (default: /home/jbrubake/.netrc)
  -h, --help                  display this help and exit
GETOPTIONSHERE
}
# Generated by getoptions (END)
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
NETRC=''
REST=''
parse_replace() {
	OPTIND=$(($#+1))
	while OPTARG= && [ $# -gt 0 ]; do
		case $1 in
			--?*=*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
				;;
			--no-*|--without-*) unset OPTARG ;;
			-[N]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" "${OPTARG#??}"' ${1+'"$@"'}
				;;
			-[h]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
				OPTARG= ;;
		esac
		case $1 in
			'-N'|'--netrc')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				NETRC="$OPTARG"
				shift ;;
			'-h'|'--help')
				usage_replace
				exit 0 ;;
			--)
				shift
				while [ $# -gt 0 ]; do
					REST="${REST} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
			[-]?*) set "unknown" "$1"; break ;;
			*)
				REST="${REST} \"\${$(($OPTIND-$#))}\""
		esac
		shift
	done
	[ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
	case $1 in
		unknown) set "Unrecognized option: $2" "$@" ;;
		noarg) set "Does not allow an argument: $2" "$@" ;;
		required) set "Requires an argument: $2" "$@" ;;
		pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
		notcmd) set "Not a command: $2" "$@" ;;
		*) set "Validation error ($1): $2" "$@"
	esac
	echo "$1" >&2
	exit 1
}
usage_replace() {
cat<<'GETOPTIONSHERE'
Usage: ix replace [OPTION] [ID]

Replace paste ID with the contents of stdin

Options:
  -N, --netrc NETRC           path to netrc file (default: /home/jbrubake/.netrc)
  -h, --help                  display this help and exit
GETOPTIONSHERE
}
# Generated by getoptions (END)
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
NETRC=''
REST=''
parse_edit() {
	OPTIND=$(($#+1))
	while OPTARG= && [ $# -gt 0 ]; do
		case $1 in
			--?*=*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
				;;
			--no-*|--without-*) unset OPTARG ;;
			-[N]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" "${OPTARG#??}"' ${1+'"$@"'}
				;;
			-[h]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
				OPTARG= ;;
		esac
		case $1 in
			'-N'|'--netrc')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				NETRC="$OPTARG"
				shift ;;
			'-h'|'--help')
				usage_edit
				exit 0 ;;
			--)
				shift
				while [ $# -gt 0 ]; do
					REST="${REST} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
			[-]?*) set "unknown" "$1"; break ;;
			*)
				REST="${REST} \"\${$(($OPTIND-$#))}\""
		esac
		shift
	done
	[ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
	case $1 in
		unknown) set "Unrecognized option: $2" "$@" ;;
		noarg) set "Does not allow an argument: $2" "$@" ;;
		required) set "Requires an argument: $2" "$@" ;;
		pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
		notcmd) set "Not a command: $2" "$@" ;;
		*) set "Validation error ($1): $2" "$@"
	esac
	echo "$1" >&2
	exit 1
}
usage_edit() {
cat<<'GETOPTIONSHERE'
Usage: ix edit [OPTION]

Edit paste ID

Options:
  -N, --netrc NETRC           path to netrc file (default: /home/jbrubake/.netrc)
  -h, --help                  display this help and exit
GETOPTIONSHERE
}
# Generated by getoptions (END)

# Top-level
parse_main "$@"
eval "set -- $REST"

# Default command is list
case $# in
    0) cmd=list ;;
    *) cmd=$1; shift
esac

# Sub-command
REST=
parse_$cmd "$@"
eval "set -- $REST"

# -a and -u are mutually exclusive
if [ -n "$ANON" ] && [ -n "$WHO" ]; then
    printf "Cannot specify both -a and -u. Exiting\n" >&2
    exit 1
fi

# Main {{{1
#
if command -v xclip >/dev/null; then
    copy='xclip -selection clipboard'
elif command -v xsel >/dev/null; then
    copy='xsel -b'
else
    copy=tee
fi
case $cmd in
    fzf)
        do_list ${NETRC:-$NETRC_DFLT} | fzf \
            --header-first \
            --header  '[^P]aste [^E]dit [^V]iew [^D]elete [^R]eload' \
            --preview 'do_get {1} | bat -pp --color always' \
            --bind    "Ctrl-V:execute(do_get {1} | bat -pp --color always)" \
            --bind    "ctrl-d:execute(do_delete '${NETRC:-$NETRC_DFLT}' {1})+reload-sync(do_list '${NETRC:-$NETRC_DFLT}')" \
            --bind    "Ctrl-E:execute(do_edit '${NETRC:-$NETRC_DFLT}' {1})" \
            --bind    "Ctrl-R:reload-sync(do_list '${NETRC:-$NETRC_DFLT}')" \
            --bind    "Ctrl-P:execute(do_paste '${NETRC:-$NETRC_DFLT}')+reload-sync(do_list '${NETRC:-$NETRC_DFLT}')" |
        cut -d' ' -f1 |
        xargs -I{} curl -s "$URL/{}" | tee /dev/tty | "$copy"
        ;;
    list)    do_list    "${NETRC:-"$NETRC_DFLT"}" ${ANON:+-a} ${WHO:+-u $WHO} ;;
    get)     do_get     "$@" ;;
    delete)  do_delete  "${NETRC:-"$NETRC_DFLT"}" "$@" ;;
    replace) do_replace "${NETRC:-"$NETRC_DFLT"}" "$@" ;;
    edit)    do_edit    "${NETRC:-"$NETRC_DFLT"}" "$1" ;;
    paste)   do_paste   "${NETRC:-"$NETRC_DFLT"}" ${ANON:+-a} "$@" ;;
esac

