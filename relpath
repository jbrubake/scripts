#!/bin/sh
#
# This work is licensed under the Creative Commons Attribution-ShareAlike 3.0
# Unported License. To view a copy of this license, visit
# http://creativecommons.org/licenses/by-sa/3.0/ or send a letter to 
# Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
#
# relpath: Print the relative path between two paths
#
# Usage: relpath SRC TGT
#
# SRC and TGT are absolute directory paths and may or may not exist.
# If either SRC or TGT exist in the filesystem, that path may be
# specified as a relative path.
#
# relpath will print the relative path to TGT from SRC

CT_FindRelativePath()
{
# Returns relative path to $2 from $1
#
# This function was taken from a Stack Overflow answer
#
# Question: https://stackoverflow.com/q/2564634
# Answer: https://stackoverflow.com/a/30778999
# Answer by: Ray Donnelly (https://stackoverflow.com/users/3257826/ray-donnelly)

# CHANGE:
# If $1 or $2 exist they can be specified as relative
# paths which will be converted to absolute paths
# If $1 or $2 do not exist they must be specified
# as absolute paths
#
# Jeremy Brubaker, November 2018

    if test -e $1; then
        local insource=$( cd $1; echo `pwd` )
    else
        local insource=$1
    fi

    if test -e $2; then
        local intarget=$( cd $2; echo `pwd` )
    else
        local intarget=$2
    fi

    # Ensure both source and target end with /
    # This simplifies the inner loop.
    case "$insource" in
        */) ;;
        *) source="$insource"/ ;;
    esac

    case "$intarget" in
        */) ;;
        *) target="$intarget"/ ;;
    esac

    local common_part=$source # for now

    local result=""

    while [ "${target#$common_part}" = "${target}" -a "${common_part}" != "//" ]; do
        # no match, means that candidate common part is not correct
        # go up one level (reduce common part)
        common_part=$(dirname "$common_part")/
        # and record that we went back
        if [ -z "${result}" ]; then
            result="../"
        else
            result="../$result"
        fi
    done

    if [ "${common_part}" = "//" ]; then
        # special case for root (no common path)
        common_part="/"
    fi

    # since we now have identified the common part,
    # compute the non-common part
    forward_part="${target#$common_part}"

    if [ -n "${result}" -a -n "${forward_part}" ]; then
        result="$result$forward_part"
    elif [ -n "${forward_part}" ]; then
        result="$forward_part"
    fi

    # if a / was added to target and result ends in / then remove it now.
    if [ "$intarget" != "$target" ]; then
        case "$result" in
            */) result=$(echo "$result" | awk '{ string=substr($0, 1, length($0)-1); print string; }' ) ;;
        esac
    fi

    echo $result

    return 0
}

echo $(CT_FindRelativePath $1 $2)
